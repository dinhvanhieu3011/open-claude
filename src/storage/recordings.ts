import * as fs from 'fs';
import * as path from 'path';
import { app } from 'electron';
import type { RecordingMetadata } from '../types';

/**
 * Get the recordings directory path
 */
export function getRecordingsDirectory(): string {
  return path.join(app.getPath('userData'), 'recordings');
}

/**
 * Ensure recordings directory exists
 */
export function ensureRecordingsDirectory(): void {
  const recordingsDir = getRecordingsDirectory();

  try {
    if (!fs.existsSync(recordingsDir)) {
      fs.mkdirSync(recordingsDir, { recursive: true });
      console.log('[Storage] Created recordings directory:', recordingsDir);
    }
  } catch (error) {
    console.error('[Storage] Error creating recordings directory:', error);
    throw error;
  }
}

/**
 * Get month directory for a given date (YYYY-MM format)
 */
function getMonthDirectory(date: Date): string {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  return path.join(getRecordingsDirectory(), `${year}-${month}`);
}

/**
 * Ensure month directory exists
 */
function ensureMonthDirectory(date: Date): string {
  const monthDir = getMonthDirectory(date);

  try {
    if (!fs.existsSync(monthDir)) {
      fs.mkdirSync(monthDir, { recursive: true });
    }
    return monthDir;
  } catch (error) {
    console.error('[Storage] Error creating month directory:', error);
    throw error;
  }
}

/**
 * Generate filename for transcript
 */
function generateFilename(metadata: RecordingMetadata): string {
  const date = new Date(metadata.timestamp);
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  const hours = String(date.getHours()).padStart(2, '0');
  const minutes = String(date.getMinutes()).padStart(2, '0');
  const seconds = String(date.getSeconds()).padStart(2, '0');

  return `${year}-${month}-${day}_${hours}-${minutes}-${seconds}_${metadata.id}.${metadata.format}`;
}

/**
 * Save transcript to file
 */
export async function saveTranscriptToFile(
  metadata: RecordingMetadata,
  content: string
): Promise<void> {
  try {
    ensureRecordingsDirectory();

    const date = new Date(metadata.timestamp);
    const monthDir = ensureMonthDirectory(date);

    const filename = generateFilename(metadata);
    const filePath = path.join(monthDir, filename);

    // Format content based on file type
    let formattedContent: string;

    switch (metadata.format) {
      case 'md':
        formattedContent = formatAsMarkdown(metadata, content);
        break;
      case 'json':
        formattedContent = formatAsJSON(metadata, content);
        break;
      case 'txt':
        formattedContent = formatAsText(metadata, content);
        break;
      default:
        formattedContent = content;
    }

    // Write file atomically
    const tempPath = filePath + '.tmp';
    fs.writeFileSync(tempPath, formattedContent, 'utf-8');
    fs.renameSync(tempPath, filePath);

    // Update metadata with file info
    metadata.transcriptPath = path.relative(getRecordingsDirectory(), filePath);
    metadata.fileSize = fs.statSync(filePath).size;

    console.log('[Storage] Saved transcript:', filePath, `(${metadata.fileSize} bytes)`);
  } catch (error) {
    console.error('[Storage] Error saving transcript:', error);
    throw error;
  }
}

/**
 * Format transcript as Markdown
 */
function formatAsMarkdown(metadata: RecordingMetadata, content: string): string {
  const date = new Date(metadata.timestamp);
  const dateStr = date.toLocaleString('vi-VN');
  const durationStr = formatDuration(metadata.duration);

  return `# ${metadata.title || 'Recording'} - ${dateStr}

**Duration:** ${durationStr}
**Mode:** ${metadata.recordingMode === 'mic+system' ? 'Microphone + System Audio' : 'Microphone Only'}
**Words:** ${metadata.wordCount || 0}

---

## Transcript

${content}

---

_Generated by Open Claude_
`;
}

/**
 * Format transcript as JSON
 */
function formatAsJSON(metadata: RecordingMetadata, content: string): string {
  const data = {
    id: metadata.id,
    timestamp: metadata.timestamp,
    duration: metadata.duration,
    title: metadata.title,
    mode: metadata.recordingMode,
    wordCount: metadata.wordCount,
    transcript: content
  };

  return JSON.stringify(data, null, 2);
}

/**
 * Format transcript as plain text
 */
function formatAsText(metadata: RecordingMetadata, content: string): string {
  const date = new Date(metadata.timestamp);
  const dateStr = date.toLocaleString('vi-VN');
  const durationStr = formatDuration(metadata.duration);

  return `Recording: ${dateStr}
Duration: ${durationStr}
Mode: ${metadata.recordingMode === 'mic+system' ? 'Microphone + System Audio' : 'Microphone Only'}

[Transcript]
${content}
`;
}

/**
 * Format duration in MM:SS format
 */
function formatDuration(seconds: number): string {
  const mins = Math.floor(seconds / 60);
  const secs = seconds % 60;
  return `${mins}m ${secs}s`;
}

/**
 * Load transcript from file
 */
export async function loadTranscript(metadata: RecordingMetadata): Promise<string> {
  try {
    const filePath = path.join(getRecordingsDirectory(), metadata.transcriptPath);

    if (!fs.existsSync(filePath)) {
      throw new Error(`Transcript file not found: ${filePath}`);
    }

    const content = fs.readFileSync(filePath, 'utf-8');
    console.log('[Storage] Loaded transcript:', filePath);

    return content;
  } catch (error) {
    console.error('[Storage] Error loading transcript:', error);
    throw error;
  }
}

/**
 * Delete transcript file
 */
export async function deleteTranscript(metadata: RecordingMetadata): Promise<void> {
  try {
    const filePath = path.join(getRecordingsDirectory(), metadata.transcriptPath);

    if (fs.existsSync(filePath)) {
      fs.unlinkSync(filePath);
      console.log('[Storage] Deleted transcript:', filePath);
    }
  } catch (error) {
    console.error('[Storage] Error deleting transcript:', error);
    throw error;
  }
}

/**
 * Get storage statistics
 */
export function getStorageStats(): { totalFiles: number; totalSize: number } {
  try {
    const recordingsDir = getRecordingsDirectory();

    if (!fs.existsSync(recordingsDir)) {
      return { totalFiles: 0, totalSize: 0 };
    }

    let totalFiles = 0;
    let totalSize = 0;

    function scanDirectory(dir: string) {
      const entries = fs.readdirSync(dir, { withFileTypes: true });

      for (const entry of entries) {
        const fullPath = path.join(dir, entry.name);

        if (entry.isDirectory()) {
          scanDirectory(fullPath);
        } else if (entry.isFile()) {
          const stats = fs.statSync(fullPath);
          totalFiles++;
          totalSize += stats.size;
        }
      }
    }

    scanDirectory(recordingsDir);

    return { totalFiles, totalSize };
  } catch (error) {
    console.error('[Storage] Error getting storage stats:', error);
    return { totalFiles: 0, totalSize: 0 };
  }
}
